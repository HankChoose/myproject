<p>{% extends "layout.html" %}
  
  {% load static %}
  {% csrf_token %}
  
  {% block title %}
  Hankwebsite
  {% endblock %}
  
  {% block body %}
 </p>
<p>&nbsp; </p>
<div>Test02</div>

<p>Debian<br>
  Ubuntu<br>
  使用root用户或具有sudo权限的用户执行以下命令，以确保您具有安装软件的权限：<br>
  sudo su<br>
  sudo -i<br>
  ********************************************************************<br>
  1.Debian安装pip，Python and django<br>
  ********************************************************************<br>
  sudo apt update<br>
  sudo apt install python3 python3-pip<br>
  python3 --version<br>
pip3 --version</p>
<p>pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple django==3.2.4<br>
  ********************************************************************<br>
  2.安装Git<br>
  ********************************************************************<br>
  sudo apt update<br>
  sudo apt install git</p>
<p>git clone https://github.com/HankChoose/projectwebsite</p>
<p>#检查当前分支与远程分支的关联<br>
  git branch -vv<br>
  #检查远程仓库的设置和地址。<br>
  git remote -v </p>
<p>hint: Pulling without specifying how to reconcile divergent branches is<br>
  hint: discouraged. You can squelch this message by running one of the following<br>
  hint: commands sometime before your next pull:<br>
  hint:<br>
  hint:   git config pull.rebase false  # merge (the default strategy)<br>
  hint:   git config pull.rebase true   # rebase<br>
  hint:   git config pull.ff only       # fast-forward only<br>
  hint:<br>
  hint: You can replace &quot;git config&quot; with &quot;git config --global&quot; to set a default<br>
  hint: preference for all repositories. You can also pass --rebase, --no-rebase,<br>
  hint: or --ff-only on the command line to override the configured default per<br>
  hint: invocation.</p>
<p>1.提交更改：如果你确定这些更改是你想要保留的，可以先提交它们。<br>
  git commit -am &quot;Committing my changes before merge&quot;<br>
  2.存储更改：如果你不想立即提交更改，但也不想丢失它们，可以使用 Git 的存储功能（stash）来保存更改。<br>
  git stash<br>
  这将把你的更改暂时保存在存储区中，使你的工作区回到干净的状态。<br>
  3.合并操作：一旦你提交或存储了更改，你就可以执行合并操作了<br>
  git merge &lt;branchname&gt;<br>
  替换 &lt;branchname&gt; 为你想要合并的分支名称。<br>
  ********************************************************************<br>
  3.安装Docker<br>
  ********************************************************************<br>
  #更新系统的软件包列表：<br>
  sudo apt update<br>
  #安装所需的软件包，以便能够通过 HTTPS 使用存储库：<br>
  sudo apt install apt-transport-https ca-certificates curl gnupg2 software-properties-common<br>
  #添加 Docker 的官方 GPG 密钥：<br>
  curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg<br>
  #添加 Docker 的存储库：<br>
  echo &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null<br>
  #更新软件包列表：<br>
  sudo apt update<br>
  #运行以下命令以安装Docker：<br>
  sudo apt install docker-ce docker-ce-cli containerd.io<br>
  #安装Docker Compose<br>
  sudo curl -L &quot;https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose<br>
  #授予执行权限：运行以下命令以授予docker-compose可执行文件执行权限：<br>
  sudo chmod +x /usr/local/bin/docker-compose<br>
  #添加软链接（可选）：如果上述步骤无效，尝试创建软链接到docker-compose可执行文件。运行以下命令：<br>
  sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose<br>
  #安装完成后，启动Docker服务：<br>
  sudo systemctl start docker</p>
<p>-------------------------------------------------------------------------------&gt;验证 Docker </p>
<p>#version<br>
  sudo docker version<br>
  #安装完成后，启动Docker服务：<br>
  sudo systemctl start docker<br>
  #要使Docker在系统启动时自动启动，请运行以下命令<br>
  sudo systemctl enable docker</p>
<p>-------------------------------------------------------------------------------&gt;docker-compose<br>
  /build/projectapp/docker-compose up -d<br>
  #查Docker实例状态<br>
  sudo docker ps -a</p>
<p>sudo iptables -L</p>
<p>sudo su<br>
  systemctl stop iptables<br>
  systemctl disable iptables</p>
<p>-------------------------------------------------------------------------------&gt;Remove docker<br>
  停止 Docker 服务：<br>
  sudo systemctl stop docker<br>
  #停止并删除所有正在运行的容器：<br>
  sudo docker stop $(sudo docker ps -aq)<br>
  sudo docker rm $(sudo docker ps -aq)<br>
  #删除 Docker 软件包：<br>
  sudo apt-get purge docker-ce docker-ce-cli containerd.io<br>
  #删除 Docker 相关文件和目录<br>
  sudo rm -rf /var/lib/docker<br>
  sudo rm -rf /etc/docker<br>
  #卸载Docker Compose<br>
  sudo rm /usr/local/bin/docker-compose<br>
  #重新加载 systemd 并清理系统状态<br>
  sudo systemctl daemon-reload<br>
  sudo systemctl reset-failed</p>
<p>-------------------------------------------------------------------------------&gt;/build/myrun/hankdel<br>
  docker stop $(docker ps -aq)<br>
  docker rm $(docker ps -aq)<br>
  docker rmi $(docker images -aq)<br>
  docker volume rm app_static<br>
  #清除 Docker 缓存<br>
  docker system prune<br>
  find /var/lib/docker/overlay2 -type f -name &quot;*projectwebsite1*&quot; -exec rm {} +<br>
  for volume in $(docker volume ls -q); do docker volume rm $volume; done</p>
<p>**********************************************************************<br>
  Clear /var/lib/docker/overlay2 --------------&gt;/build/myrun/hankdel<br>
  **********************************************************************<br>
  #停止所有正在运行的 Docker 容器<br>
  docker stop $(docker ps -aq<br>
  #清理未使用的镜像<br>
  docker image prune<br>
  #清理未使用的容器卷<br>
  docker volume prune<br>
  #清理未使用的 Docker 网络<br>
  docker network prune<br>
  #强制删除<br>
  docker network prune -f</p>
<p>此命令将查找并删除大小&lt;2MB or &gt;2M的文件。您可以根据需要调整 size 参数的值。<br>
  #ask?<br>
  find /var/lib/docker/overlay2 -type f -size +2M -exec ls -lh {} \;<br>
  find /var/lib/docker/overlay2 -type f -name &quot;projectwebsite1&quot; -exec rm {} +</p>
<p>#No ask<br>
  find /var/lib/docker/overlay2 -type f -size -2M -delete<br>
  find /var/lib/docker/overlay2 -type f -size +2M -delete<br>
  find /var/lib/docker/overlay2 -type f -name &quot;*projectwebsite1*&quot; -delete</p>
<p>url(&quot;{% static 'images/bg-shape.png' %}&quot;);<br>
  url(&quot;{% static 'images/coming-soon.jpg' %}&quot;);</p>
<p>****************************************************************************<br>
  STATIC_URL andSTATIC_ROOT<br>
  ****************************************************************************<br>
  from django.shortcuts import render<br>
  from django.conf import settings</p>
<p>def index(request):</p>
<p> context = {<br>
  'STATIC_ROOT': settings.STATIC_ROOT,<br>
  'STATIC_URL': settings.STATIC_URL,<br>
  }<br>
  <br>
  static_root = settings.STATIC_ROOT<br>
  static_url = settings.STATIC_URL<br>
  return render(request, 'index.html', context)</p>
<p>----------------------------------------------------------------index.html</p>
<p> {% load static %}&lt;br&gt;<br>
  STATIC_URL: {{ STATIC_URL }}&lt;br&gt;<br>
  STATIC_ROOT: {{ STATIC_ROOT }}&lt;br&gt;<br>
  <br>
  <br>
</p>
<p>在GitHub上创建一个新的仓库：在GitHub上创建一个新的仓库，用于存储你的网站代码和Dockerfile。</p>
<p>编写Dockerfile：在你的仓库中创建一个名为 Dockerfile 的文件，并编写用于构建Docker镜像的指令。确保Dockerfile 中包含将你的网站代码复制到容器内部的步骤，并设置正确的运行时环境。</p>
<p>sudo yum update -y<br>
  sudo amazon-linux-extras install docker -y<br>
  sudo service docker start<br>
  sudo usermod -a -G docker ec2-user<br>
  sudo chkconfig docker on<br>
  sudo curl -L &quot;https://github.com/docker/compose/releases/download/&lt;version&gt;/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose<br>
  sudo chmod +x /usr/local/bin/docker-compose<br>
</p>
<p>****************************************************************************<br>
  Mix<br>
  ****************************************************************************<br>
  这些命令将更新系统、安装Docker和Docker Compose，启动Docker服务，并将当前用户添加到 docker 用户组中</p>
<p>在AWS EC2上克隆你的GitHub仓库：使用 git clone 命令将你的GitHub仓库克隆到AWS EC2实例上。例如：<br>
  git clone https://github.com/your-username/your-repo.git</p>
<p>编写Docker Compose文件：在你的仓库中创建一个名为 docker-compose.yml 的文件，并定义用于运行你的网站容器的服务。确保 Docker Compose 文件与你的 Dockerfile 相关联，并设置正确的容器端口映射等配置。</p>
<p>创建GitHub Action工作流程：在你的仓库中创建一个名为 .github/workflows/deploy.yml 的文件，用于定义GitHub Actions工作流程。以下是一个示例工作流程的模板：<br>
  name: Docker Deployment</p>
<p>on:<br>
  push:<br>
  branches:<br>
  - main</p>
<p>jobs:<br>
  build:<br>
  runs-on: ubuntu-latest</p>
<p> steps:<br>
  - name: Checkout repository<br>
  uses: actions/checkout@v2</p>
<p> - name: Login to Docker Hub<br>
  uses: docker/login-action@v1<br>
  with:<br>
  username: ${{ secrets.DOCKER_USERNAME }}<br>
  password: ${{ secrets.DOCKER_PASSWORD }}</p>
<p> - name: Build and push Docker image<br>
  uses: docker/build-push-action@v2<br>
  with:<br>
  context: .<br>
  push: true<br>
  tags: your-dockerhub-username/your-image-name:latest</p>
<p> - name: SSH into EC2 instance<br>
  uses: appleboy/ssh-action@master<br>
  with:<br>
  host: ${{ secrets.EC2_HOST }}<br>
  username: ${{ secrets.EC2_USERNAME }}<br>
  key: ${{ secrets.EC2_PRIVATE_KEY }}<br>
  script: |<br>
  cd /path/to/your/repo<br>
  git pull<br>
  docker-compose up -d</p>
<p>这个工作流程将在每次推送到 &quot;main&quot; 分支时执行。它首先检出仓库，然后使用 Docker 登录到 Docker Hub（如果你计划将镜像推送到 Docker Hub）。接下来，它将构建和推送 Docker 镜像，最后通过 SSH 连接到 AWS EC2 实例并执行部署命令。</p>
<p>设置GitHub仓库的Secrets：在GitHub仓库的设置中，创建以下 Secrets（密钥）：</p>
<p>DOCKER_USERNAME：你的Docker Hub用户名。<br>
  DOCKER_PASSWORD：你的Docker Hub密码。<br>
  EC2_HOST：你的AWS EC2实例的主机名或IP地址。<br>
  EC2_USERNAME：连接到AWS EC2实例的用户名。<br>
  EC2_PRIVATE_KEY：用于SSH连接的AWS EC2实例的私钥。<br>
  这些 Secrets 将用于在工作流程中进行身份验证和连接到AWS EC2实例。</p>
<p>推送代码到GitHub仓库：将你的网站代码、Dockerfile、docker-compose.yml 和 GitHub Actions 工作流程文件推送到GitHub仓库的 &quot;main&quot; 分支中。</p>
<p>触发自动部署：现在，每当你将代码推送到 &quot;main&quot; 分支时，GitHub Actions 将自动执行工作流程，构建和推送Docker镜像，并在AWS EC2上部署你的网站。</p>
<p>请注意，上述步骤中涉及的命令、配置和工作流程示例可能需要根据你的具体需求和环境进行修改。确保根据你的情况进行适当的调整。<br>
</p>
<p>在GitHub上创建一个新的仓库，并将本地的Django项目推送到该仓库。</p>
<p>在本地的Django项目根目录中创建一个名为.github/workflows的文件夹。</p>
<p>在.github/workflows文件夹中创建一个名为deploy.yml的YAML文件，用于定义工作流。</p>
<p>在deploy.yml文件中添加以下内容：<br>
  name: Deploy to AWS</p>
<p>on:<br>
  push:<br>
  branches:<br>
  - main  # 或者您使用的主分支名称</p>
<p>jobs:<br>
  deploy:<br>
  runs-on: ubuntu-latest</p>
<p> steps:<br>
  - name: Checkout code<br>
  uses: actions/checkout@v2</p>
<p> - name: Configure AWS credentials<br>
  uses: aws-actions/configure-aws-credentials@v1<br>
  with:<br>
  aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}<br>
  aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}<br>
  aws-region: &lt;AWS_REGION&gt;  # 替换为您的AWS区域，例如us-east-1</p>
<p> - name: Login to Amazon ECR<br>
  id: login-ecr<br>
  uses: aws-actions/amazon-ecr-login@v1</p>
<p> - name: Build and push Docker image<br>
  env:<br>
  ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}<br>
  IMAGE_TAG: ${{ github.sha }}<br>
  run: |<br>
  docker build -t $ECR_REGISTRY/my-django-app:$IMAGE_TAG .<br>
  docker push $ECR_REGISTRY/my-django-app:$IMAGE_TAG</p>
<p> - name: Deploy to AWS EC2<br>
  env:<br>
  ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}<br>
  IMAGE_TAG: ${{ github.sha }}<br>
  run: |<br>
  aws ecs update-service --cluster &lt;ECS_CLUSTER_NAME&gt; --service &lt;ECS_SERVICE_NAME&gt; --force-new-deployment --region &lt;AWS_REGION&gt;  # 替换为您的ECS集群和服务名称，以及AWS区域<br>
  <br>
  在AWS控制台上创建一个ECS集群和服务，以及一个ECR存储库。将deploy.yml文件中的&lt;ECS_CLUSTER_NAME&gt;和&lt;ECS_SERVICE_NAME&gt;替换为您的ECS集群和服务名称。</p>
<p>在AWS控制台上创建一个IAM用户，并授予该用户适当的权限以访问ECS和ECR服务。获取该IAM用户的Access Key ID和Secret Access Key。</p>
<p>在GitHub仓库的&quot;Settings&quot;页面中，点击&quot;Secrets&quot;选项卡，然后创建两个新的仓库秘钥：AWS_ACCESS_KEY_ID和AWS_SECRET_ACCESS_KEY，并分别填入上一步中创建的IAM用户的Access Key ID和Secret Access Key。</p>
<p>将修改后的代码提交到GitHub仓库，GitHub Actions会自动触发工作流程，将Django Docker镜像构建并推送到AWS ECR，然后更新ECS服务进行部署。<br>
</p>
<p></p>
<p>{% endblock %}</p>
